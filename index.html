<!--
Versão do USUÁRIO — Repositório de Documentos (diagnóstico de raw + fallback robusto)

Atualização importante aplicada:
- Agora, ao carregar a lista, o script testa se o `download_url` (raw) de cada arquivo está acessível (HEAD request). Isso permite identificar quais arquivos retornam 404/403 (possível Git LFS ou problema no raw).
- A tabela mostra um **badge** indicando se o raw está acessível (✔️) ou se há problema (⚠️ - usar fallback). Para arquivos com problema, o botão Visualizar abre a página do GitHub (`html_url`) diretamente, evitando erro 404.
- A função de preview tenta exibir PDFs/ imagens/ textos via blob. Se o raw falhar, faz fallback automático para a página do GitHub.

Observações técnicas:
- Testes HEAD podem ser bloqueados por CORS em alguns casos; quando o HEAD falhar, tentamos um GET leve como second check.
- Se muitos arquivos forem testados, a API do GitHub pode aplicar rate limits — isso é raro para pequenas listas, mas cuidado em repositórios com centenas de arquivos.
- Se os arquivos estiverem no Git LFS, o raw frequentemente não estará disponível: o GitHub serve um ponteiro em vez do conteúdo bruto. Nesse caso reenvie sem LFS ou hospede os PDFs em storage alternativo.

Uso: atualize as constantes OWNER/REPO/PATH no topo do script e teste.
-->

<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Repositório — Documentos</title>
  <style>
    :root{
      --bg: #fffcfa;        /* fundo suave */
      --card: #ffffff;      /* cartões */
      --accent: #00c1f6;    /* ação / detalhes */
      --dark: #023b6b;      /* texto / títulos */
      --muted: rgba(2,59,107,0.65);
      --border: rgba(2,59,107,0.06);
      --ok: #16a34a;
      --warn: #d97706;
    }

    *{box-sizing:border-box}
    body{font-family:Inter, Arial, sans-serif; background:var(--bg); color:var(--dark); margin:0; padding:28px}
    a{color:var(--accent)}

    .wrap{max-width:980px;margin:0 auto}
    header{display:flex;align-items:center;gap:12px}
    h1{margin:0;font-size:20px;color:var(--dark)}
    p.lead{color:var(--muted);margin-top:6px}

    .card{background:var(--card);border-radius:10px;padding:16px;box-shadow:0 6px 20px rgba(2,59,107,0.04);margin-top:18px;border:1px solid var(--border)}

    .controls{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .search{flex:1;min-width:220px}
    input[type=search]{width:100%;padding:10px 12px;border-radius:10px;border:1px solid rgba(2,59,107,0.08);font-size:15px;background:transparent;color:var(--dark)}
    input[type=search]::placeholder{color:rgba(2,59,107,0.35)}

    .filters{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px}
    .filter-item{display:flex;align-items:center;gap:6px;background:rgba(0,193,246,0.06);padding:6px 10px;border-radius:999px;border:1px solid rgba(0,193,246,0.12);font-size:13px;color:var(--dark)}
    .filter-item input{transform:scale(1.1);margin:0}

    table{width:100%;border-collapse:collapse;margin-top:12px}
    th,td{padding:12px;text-align:left;border-bottom:1px solid rgba(2,59,107,0.06)}
    th{color:var(--muted);font-size:13px}
    .muted{color:var(--muted);font-size:13px}
    .small{font-size:13px}
    .right{text-align:right}

    .btn{display:inline-block;padding:8px 12px;border-radius:10px;text-decoration:none;border:1px solid rgba(0,0,0,0.04);background:transparent;color:var(--accent);font-weight:600;cursor:pointer}
    .btn-primary{background:var(--accent);color:#023b6b;border:0}

    .actions{display:flex;gap:8px}

    .badge-ok{color:var(--ok);font-weight:700;margin-right:8px}
    .badge-warn{color:var(--warn);font-weight:700;margin-right:8px}

    .modal-backdrop{position:fixed;inset:0;background:rgba(2,59,107,0.28);display:none;align-items:center;justify-content:center;padding:20px;z-index:999}
    .modal{background:var(--card);border-radius:10px;max-width:980px;width:100%;max-height:90vh;overflow:auto;box-shadow:0 16px 48px rgba(2,59,107,0.16);border:1px solid rgba(2,59,107,0.06)}
    .modal header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid rgba(2,59,107,0.04)}
    .modal .body{padding:14px}
    .modal iframe{width:100%;height:70vh;border:0;border-radius:6px}
    .modal img{max-width:100%;height:auto;display:block;margin:0 auto;border-radius:6px}
    pre.txtview{white-space:pre-wrap;word-wrap:break-word;background:#fbfeff;padding:12px;border-radius:8px;border:1px solid rgba(2,59,107,0.03)}
    .close-btn{background:transparent;border:1px solid rgba(2,59,107,0.06);color:var(--dark);border-radius:8px;padding:8px 10px;cursor:pointer}

    .notice{margin-top:12px;padding:10px;border-radius:8px;background:linear-gradient(180deg,#ffffff,#fffcfa);color:var(--dark);border:1px solid rgba(2,59,107,0.03)}

    @media (max-width:720px){
      th,td{padding:10px}
      .modal iframe{height:60vh}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1 style="color:var(--dark)">Repositório de Documentos</h1>
    </header>
    <p class="lead">Pesquise e acesse documentos disponibilizados pelo administrador. Você pode visualizar diretamente (PDF/imagem/texto) ou baixar. O sistema agora indica se o arquivo raw está acessível (✔️) ou se há problema (⚠️).</p>

    <div class="card">
      <div class="controls">
        <div class="search">
          <label class="small muted">Pesquisar</label>
          <input id="search" type="search" placeholder="Digite parte do nome do documento...">
        </div>

        <div style="min-width:150px;text-align:right">
          <label class="small muted">Arquivos</label>
          <div id="count" class="small">—</div>
        </div>
      </div>

      <div id="filters" class="filters" aria-label="Filtros de categoria"></div>

      <div id="resultsArea" style="margin-top:12px"></div>

      <div class="notice">OBS: Uploads são feitos apenas pelo administrador no GitHub. Esta página é somente para visualização/consulta.</div>
    </div>
  </div>

  <!-- Modal de visualização -->
  <div id="modal" class="modal-backdrop" role="dialog" aria-hidden="true">
    <div class="modal" role="document">
      <header>
        <div id="modalTitle" style="font-weight:700;color:var(--dark)">Visualizando</div>
        <div style="display:flex;gap:8px;align-items:center">
          <a id="modalDownload" class="btn" href="#" target="_blank" rel="noopener">Baixar</a>
          <button id="closeModal" class="close-btn">Fechar</button>
        </div>
      </header>
      <div class="body" id="modalBody">
        <!-- conteúdo injetado -->
      </div>
    </div>
  </div>

  <script>
    // === CONFIGURE AQUI: substitua pelos valores do seu repositório público ===
    const OWNER = 'Rcs1992'    // ex: rodrigoc2santos
    const REPO  = 'repositorio_cer'     // ex: meus-documentos
    const PATH  = 'documents'         // pasta onde os arquivos ficam no repositório
    // ========================================================================

    // Categorias e palavras-chaves para detecção automática
    const CATEGORIES = [
      { key:'pops', label:'POPs', keywords:['pop','pops'] },
      { key:'fluxos', label:'Fluxos', keywords:['fluxo','fluxos'] },
      { key:'institucional', label:'Documentos Institucionais', keywords:['institucional','documento institucional','documentos institucionais','institucional','documento'] },
      { key:'formularios', label:'Formulários', keywords:['form','formulario','formulário','formularios','formulários'] }
    ]

    const searchInput = document.getElementById('search')
    const resultsArea = document.getElementById('resultsArea')
    const countEl = document.getElementById('count')
    const filtersEl = document.getElementById('filters')

    let files = []
    let activeFilters = new Set()

    document.addEventListener('DOMContentLoaded', () => {
      searchInput.addEventListener('input', () => renderList(files))
      loadFiles()
      searchInput.addEventListener('keydown', e => { if(e.key === 'Escape') { searchInput.value=''; renderList(files) } })
      document.getElementById('closeModal').addEventListener('click', closeModal)
      document.getElementById('modal').addEventListener('click', (e) => { if(e.target.id === 'modal') closeModal() })
    })

    async function loadFiles(){
      resultsArea.innerHTML = '<div class="muted">Carregando lista de documentos...</div>'
      if(!OWNER || !REPO){ resultsArea.innerHTML = '<div class="muted">OWNER/REPO não configurado. Edite as constantes no arquivo.</div>'; return }
      const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodeURIComponent(PATH)}`
      try{
        const res = await fetch(url)
        if(!res.ok){ resultsArea.innerHTML = `<div class="muted">Erro ao acessar repositório (status ${res.status}). Confirme as configurações e se o repo é público.</div>`; return }
        const data = await res.json()
        // mapear download_url e html_url (html_url direciona para a página do GitHub do arquivo)
        files = data.filter(i => i.type === 'file').map(f => ({ name: f.name, size: f.size, download_url: f.download_url, html_url: f.html_url }))

        // detectar categoria para cada arquivo
        files.forEach(f => f.category = detectCategory(f.name))

        // checar disponibilidade do download_url para cada arquivo (HEAD -> GET fallback)
        await Promise.all(files.map(f => checkRawAvailability(f)))

        // montar filtros automaticamente (usamos categorias pre-definidas + outros)
        buildFilters()
        renderList(files)
      }catch(err){
        resultsArea.innerHTML = '<div class="muted">Erro ao acessar API: '+ err.message +'</div>'
      }
    }

    // testa se o download_url responde OK
    async function checkRawAvailability(file){
      file.rawAccessible = false
      if(!file.download_url) return
      try{
        // primeiro tenta HEAD
        const controller = new AbortController(); const timeout = setTimeout(()=>controller.abort(), 6000)
        let res = await fetch(file.download_url, { method:'HEAD', signal: controller.signal })
        clearTimeout(timeout)
        if(res && res.ok){ file.rawAccessible = true; return }
      }catch(e){ /* ignora */ }

      // HEAD pode falhar por CORS; tenta GET com pequeno range como alternativa
      try{
        const controller2 = new AbortController(); const timeout2 = setTimeout(()=>controller2.abort(), 6000)
        const res2 = await fetch(file.download_url, { method:'GET', headers:{ 'Range':'bytes=0-1023' }, signal: controller2.signal })
        clearTimeout(timeout2)
        if(res2 && (res2.status === 200 || res2.status === 206)) { file.rawAccessible = true; return }
      }catch(e){ /* ignora */ }

      // se chegou aqui, raw não acessível
      file.rawAccessible = false
    }

    function detectCategory(name){
      const n = (name||'').toLowerCase()
      for(const c of CATEGORIES){
        for(const kw of c.keywords){ if(n.includes(kw)) return c.key }
      }
      return 'outros'
    }

    function buildFilters(){
      filtersEl.innerHTML = ''
      activeFilters = new Set()
      // adicionar categorias pre-definidas
      CATEGORIES.forEach(c => {
        const checked = true
        activeFilters.add(c.key)
        const div = document.createElement('label')
        div.className = 'filter-item'
        div.innerHTML = `<input type="checkbox" data-key="${c.key}" ${checked? 'checked':''}> ${c.label}`
        filtersEl.appendChild(div)
      })
      // adicionar 'Outros'
      const divo = document.createElement('label')
      divo.className = 'filter-item'
      divo.innerHTML = `<input type="checkbox" data-key="outros" checked> Outros`
      filtersEl.appendChild(divo)

      // listeners
      filtersEl.querySelectorAll('input[type=checkbox]').forEach(chk => chk.addEventListener('change', (e)=>{
        const key = chk.getAttribute('data-key')
        if(chk.checked) activeFilters.add(key); else activeFilters.delete(key)
        renderList(files)
      }))
    }

    function renderList(list){
      const q = (searchInput.value || '').trim().toLowerCase()
      const filtered = list.filter(f => {
        const matchesQuery = f.name.toLowerCase().includes(q)
        const matchesFilter = activeFilters.size === 0 ? true : activeFilters.has(f.category)
        return matchesQuery && matchesFilter
      })
      countEl.textContent = filtered.length
      if(filtered.length === 0){ resultsArea.innerHTML = '<div class="muted">Nenhum arquivo encontrado.</div>'; return }

      let html = '<table><thead><tr><th>Nome</th><th class="right">Tamanho</th><th>Ações</th></tr></thead><tbody>'
      filtered.forEach(f => {
        const kb = Math.round((f.size||0)/10.24)/100
        const badge = f.rawAccessible ? '<span class="badge-ok">✔️</span>' : '<span class="badge-warn">⚠️</span>'
        // data-html é a página do GitHub (fallback), data-download é o link raw/download
        html += `<tr><td class="small">${badge}${escapeHtml(f.name)}</td><td class="right small">${kb} KB</td><td class="small"><div class="actions"><button style=\"background:transparent;border:1px solid rgba(2,59,107,0.06);border-radius:8px;padding:8px 10px;cursor:pointer;color:var(--dark);\" data-download=\"${encodeURI(f.download_url||'')}\" data-html=\"${encodeURI(f.html_url||'')}\" data-name=\"${escapeHtmlAttr(f.name)}\" class=\"viewBtn\">Visualizar</button><a class=\"btn\" href=\"${encodeURI(f.rawAccessible?f.download_url:f.html_url||f.download_url)}\" target=\"_blank\" rel=\"noopener\">Baixar</a></div></td></tr>`
      })
      html += '</tbody></table>'
      resultsArea.innerHTML = html

      document.querySelectorAll('.viewBtn').forEach(btn => btn.addEventListener('click', (e)=>{
        const downloadUrl = decodeURI(btn.getAttribute('data-download'))
        const htmlUrl = decodeURI(btn.getAttribute('data-html'))
        const name = btn.getAttribute('data-name')
        openPreviewWithFallback(downloadUrl, htmlUrl, name)
      }))
    }

    function getExtension(name){ const parts = name.split('.') ; if(parts.length < 2) return '' ; return parts.pop().toLowerCase() }

    async function openPreviewWithFallback(downloadUrl, htmlUrl, name){
      const ext = getExtension(name)
      const modal = document.getElementById('modal')
      const modalBody = document.getElementById('modalBody')
      const modalTitle = document.getElementById('modalTitle')
      const modalDownload = document.getElementById('modalDownload')

      modalTitle.textContent = name
      modalDownload.href = downloadUrl || htmlUrl || '#'

      const images = ['png','jpg','jpeg','gif','bmp','webp']
      const textTypes = ['txt','md','csv','log','json']

      modalBody.innerHTML = '<div class="muted">Carregando visualização...</div>'
      modal.style.display = 'flex'
      modal.setAttribute('aria-hidden','false')

      if(modal.dataset.blobUrl){ try{ URL.revokeObjectURL(modal.dataset.blobUrl) }catch(e){} delete modal.dataset.blobUrl }

      try{
        if(ext === 'pdf'){
          if(!downloadUrl){ window.open(htmlUrl, '_blank', 'noopener'); closeModal(); return }

          // tenta buscar raw como blob
          const res = await fetch(downloadUrl)
          if(res.ok){
            const blob = await res.blob()
            const blobUrl = URL.createObjectURL(blob)
            modalBody.innerHTML = `<iframe src="${blobUrl}"></iframe>`
            modal.dataset.blobUrl = blobUrl
            return
          }

          // fallback: abrir página do GitHub
          window.open(htmlUrl, '_blank', 'noopener')
          closeModal()
          return

        }else if(images.includes(ext)){
          modalBody.innerHTML = `<img src="${downloadUrl||htmlUrl}" alt="${escapeHtml(name)}">`
        }else if(textTypes.includes(ext)){
          const res = await fetch(downloadUrl||htmlUrl)
          if(res.ok){ const txt = await res.text(); modalBody.innerHTML = `<pre class=\"txtview\">${escapeHtml(txt)}</pre>` } else { window.open(htmlUrl, '_blank', 'noopener'); closeModal() }
        }else{
          modalBody.innerHTML = '<div class="muted">Pré-visualização não disponível para este tipo de arquivo. Use o botão Baixar.</div>'
        }
      }catch(err){
        try{ window.open(htmlUrl, '_blank', 'noopener') }catch(e){}
        closeModal()
      }
    }

    function closeModal(){
      const modal = document.getElementById('modal')
      if(modal.dataset.blobUrl){ try{ URL.revokeObjectURL(modal.dataset.blobUrl) }catch(e){} delete modal.dataset.blobUrl }
      modal.style.display = 'none'
      modal.setAttribute('aria-hidden','true')
      document.getElementById('modalBody').innerHTML = ''
    }

    function escapeHtml(s){ if(!s) return '' ; return String(s).replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',"'":'&#39;'}[c])) }
    function escapeHtmlAttr(s){ return escapeHtml(s).replace(/\"/g,'&quot;') }
  </script>
</body>
</html>
